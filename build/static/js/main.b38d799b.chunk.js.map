{"version":3,"sources":["components/Swiper.jsx","App.js","serviceWorker.js","index.js"],"names":["clientW","criticalWidth","touchStatus","stStartX","stPrevX","stAutoNext","stDirectionFlag","activeIndex","touchCount","_autoPlayTimer","isSupportGetBoundingClientRect","document","documentElement","getBoundingClientRect","Swiper","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","currentList","transX","isTransToX","firstSwiperItem","lastSwiperItem","swiperItemCount","_this2","urlList","isMobile","length","slice","concat","map","url","index","_id","criticalValue","getActiveIndex","startIndex","setState","clearTimeout","setTimeout","autoPlayFn","e","ignoreTouch","refs","sliderWrapper","left","swiperContainer","touches","singleTouchStartFn","preventDefault","singleTouchMoveFn","clientX","singleTouchEndFn","toX","diffX","wholeBlock","Math","floor","abs","ceil","getSingleTouchEndMultipleChildToX","gotoX","_this3","target","className","transEndFn","change","_this4","autoPlayDelay","correctDurationAct","duration","click","navigator","userAgent","toLowerCase","match","_this5","react_default","a","createElement","ref","style","width","height","clientH","onClick","swipeClick","bind","transform","transition","onTouchStart","touchstartFn","onTouchMove","touchmoveFn","onTouchEnd","touchendFn","onTransitionEnd","transitionendFn","item","backgroundImage","backgroundSize","key","showCounter","counterStyle","Component","defaultProps","clientWidth","App","value","parseInt","swiper","goto","components_Swiper","i","console","log","type","onChange","inputIndex","Boolean","window","location","hostname","ReactDOM","render","src_App","getElementById","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.b38d799b.chunk.js","sourcesContent":["import React, { Component } from 'react'\r\nimport PropTypes from 'prop-types'\r\nimport './swiper.css'\r\n\r\n// 滚动容器的宽度\r\nlet clientW = 375\r\nlet criticalWidth = 0\r\n// 用户标识当前的滑动状态\r\nlet touchStatus = 0\r\n\r\n// 单指操作 - 滑动坐标相关\r\n// touchStart 点击坐标\r\nlet stStartX = 0\r\n// 上个周期中的tranlateX 坐标\r\nlet stPrevX = 0\r\n// 当前是否需要自动滑动到下一张图片\r\nlet stAutoNext = 0\r\n// 滑动的方向，-1 为右滑，1 为左滑\r\nlet stDirectionFlag = 0\r\n\r\n// 当前正在预览的图片次序，用于位置计算\r\nlet activeIndex = 0\r\n// sliderWrapper上的触摸点数量\r\nlet touchCount = 0\r\n// 用于取消自动轮播（如果指定了的话）\r\nlet _autoPlayTimer = null\r\n// getBoundingClientRect的兼容性\r\nconst isSupportGetBoundingClientRect = typeof document.documentElement.getBoundingClientRect === 'function'\r\n\r\nclass Swiper extends Component {\r\n  constructor(props) {\r\n    super(props)\r\n    this.state = {\r\n      // 当前显示在DOM中的图片列表\r\n      currentList: [],\r\n      // 单指滑动的位移\r\n      transX: 0,\r\n      // 当前正在预览的图片次序，用于给模板渲染计数器使用\r\n      activeIndex: 1,\r\n      // 正在自动滚动到固定位置的过程中\r\n      isTransToX: false,\r\n      firstSwiperItem: null,\r\n      lastSwiperItem: null,\r\n      swiperItemCount: 0\r\n    }\r\n  }\r\n\r\n  static defaultProps = {\r\n    urlList: [],\r\n    backgroundSize: 'cover',\r\n    clientW: document.documentElement.clientWidth,\r\n    clientH: 200,\r\n    showCounter: false,\r\n    counterStyle: null,\r\n    startIndex: 0,\r\n    criticalValue: 1 / 4,\r\n    autoPlayDelay: null,\r\n    duration: 350,\r\n    click: null,\r\n    change: null,\r\n  }\r\n\r\n  componentWillMount () {\r\n    let { urlList } = this.props\r\n    if (!this.isMobile()) {\r\n      urlList = ['https://dummyimage.com/375x100/FB8A80?text=please+browse+on+mobile']\r\n    }\r\n    let currentList = urlList.length > 1\r\n      ? urlList.slice(-1).concat(urlList, urlList.slice(0, 1)).map((url, index) => ({ url, _id: index }))\r\n      : urlList.map((url, index) => ({ url, _id: index }))\r\n    clientW = this.props.clientW\r\n    criticalWidth = clientW * this.props.criticalValue\r\n    if (currentList.length > 1) {\r\n      // 因为首尾都多加了一个swiperItem元素，所以顺延一位\r\n      activeIndex = this.getActiveIndex(this.props.startIndex + 1)\r\n      let transX = stPrevX = -clientW * activeIndex\r\n      this.setState({ activeIndex, transX })\r\n    }\r\n    // 自动轮播\r\n    clearTimeout(_autoPlayTimer)\r\n    _autoPlayTimer = setTimeout(() => {\r\n      this.autoPlayFn()\r\n    }, 14)\r\n    this.setState({ swiperItemCount: currentList.length, currentList })\r\n  }\r\n\r\n  componentWillUnmount () {\r\n    clearTimeout(_autoPlayTimer)\r\n  }\r\n\r\n  touchstartFn (e) {\r\n    // 取消还没结束的自动轮播（如果指定了轮播的话）\r\n    clearTimeout(_autoPlayTimer)\r\n    if (this.ignoreTouch()) return\r\n    if (this.state.isTransToX) {\r\n      if (!isSupportGetBoundingClientRect) {\r\n        return touchStatus = 0\r\n      }\r\n      let isTransToX = false\r\n      let transX = stPrevX = this.refs.sliderWrapper.getBoundingClientRect().left - this.refs.swiperContainer.getBoundingClientRect().left\r\n      this.setState({ isTransToX, transX })\r\n    }\r\n    touchStatus = 1\r\n    touchCount = e.touches.length\r\n    this.singleTouchStartFn(e)\r\n  }\r\n\r\n  touchmoveFn (e) {\r\n    e.preventDefault()\r\n    if (this.ignoreTouch() || touchStatus !== 1) return\r\n    if (this.state.swiperItemCount !== 1) {\r\n      this.singleTouchMoveFn(e)\r\n    }\r\n  }\r\n\r\n  touchendFn (e) {\r\n    touchCount = e.touches.length\r\n    if (this.ignoreTouch() || touchStatus !== 1) return\r\n    if (touchCount !== 0) {\r\n      stStartX = e.touches[touchCount - 1].clientX\r\n      stPrevX = this.state.transX\r\n      return\r\n    }\r\n    this.singleTouchEndFn(e)\r\n  }\r\n\r\n  getSingleTouchEndMultipleChildToX () {\r\n    let toX = 0\r\n    let diffX = this.state.transX + clientW * activeIndex\r\n    const wholeBlock = Math.floor(diffX / clientW)\r\n    // 如果连续滑过超过一个 swiperItem 块，当做一个来处理\r\n    if (Math.abs(diffX) > clientW) {\r\n      activeIndex = Math.ceil(-this.state.transX / clientW)\r\n      diffX = diffX - clientW * wholeBlock\r\n    }\r\n    // diffX 大于0 说明是右滑，小于0 则是左滑\r\n    if (diffX > 0) {\r\n      stDirectionFlag = -1\r\n      stAutoNext = diffX > criticalWidth\r\n      toX = stAutoNext ? -clientW * (activeIndex - 1) : -clientW * activeIndex\r\n    } else if (diffX < 0) {\r\n      stDirectionFlag = 1\r\n      stAutoNext = Math.abs(diffX) > criticalWidth\r\n      toX = stAutoNext ? -clientW * (activeIndex + 1) : -clientW * activeIndex\r\n    } else {\r\n      stDirectionFlag = 0\r\n      stAutoNext = false\r\n      toX = -clientW * activeIndex\r\n    }\r\n    activeIndex = this.getActiveIndex(activeIndex + (stAutoNext ? stDirectionFlag : 0))\r\n    this.setState({ activeIndex })\r\n    return toX\r\n  }\r\n\r\n  singleTouchStartFn (e) {\r\n    stStartX = e.touches[touchCount - 1].clientX\r\n    if (touchCount > 1) {\r\n      stPrevX = this.state.transX\r\n    }\r\n  }\r\n\r\n  singleTouchMoveFn (e) {\r\n    let transX = e.touches[touchCount - 1].clientX - stStartX + stPrevX\r\n    if (transX > 0) {\r\n      // 滑动到到第一个了\r\n      stStartX = e.touches[touchCount - 1].clientX\r\n      // 矫正到正确位置\r\n      stPrevX = transX = -clientW * (this.state.swiperItemCount - 2)\r\n    } else if (transX < -clientW * (this.state.swiperItemCount - 1)) {\r\n      // 滑动到最后一个了\r\n      stStartX = e.touches[touchCount - 1].clientX\r\n      // 矫正到正确位置\r\n      stPrevX = transX = -clientW\r\n    }\r\n    this.setState({ transX })\r\n  }\r\n\r\n  singleTouchEndFn (e) {\r\n    let toX = this.state.swiperItemCount === 1 ? 0 : this.getSingleTouchEndMultipleChildToX()\r\n    this.gotoX(toX)\r\n  }\r\n\r\n  transEndFn () {\r\n    activeIndex = this.getActiveIndex(activeIndex)\r\n    stPrevX = -clientW * activeIndex\r\n    this.setState({ activeIndex, transX: stPrevX })\r\n    // setTimeout是为了避免当 autoPlayDelay值被指定为 0 时无限轮播出现问题\r\n    // 16.7 是 1000/60 的大约值\r\n    clearTimeout(_autoPlayTimer)\r\n    _autoPlayTimer = setTimeout(() => {\r\n      this.autoPlayFn()\r\n    }, 16.7)\r\n  }\r\n\r\n  transitionendFn (e) {\r\n    if (e.target.className === 'swiper-wrapper') {\r\n      if (this.state.isTransToX) {\r\n        this.setState({ isTransToX: false })\r\n        // 单指操作 - 自动滑动结束\r\n        this.transEndFn()\r\n        this.props.change && this.props.change(activeIndex)\r\n      }\r\n    }\r\n  }\r\n\r\n  getActiveIndex (index) {\r\n    if (this.state.swiperItemCount === 1) return 0\r\n    if (index >= this.state.swiperItemCount - 1) return 1\r\n    if (index <= 0) return this.state.swiperItemCount - 2\r\n    return index\r\n  }\r\n\r\n  autoPlayFn () {\r\n    // 判断是否满足自动轮播的条件\r\n    if (this.state.swiperItemCount > 1 && (typeof this.props.autoPlayDelay === 'number' && this.props.autoPlayDelay >= 0) && touchCount === 0 && this.state.transX % clientW === 0) {\r\n      clearTimeout(_autoPlayTimer)\r\n      _autoPlayTimer = setTimeout(() => {\r\n        activeIndex = activeIndex + 1\r\n        this.setState({ transX: -clientW * activeIndex, isTransToX: true })\r\n        this.correctDurationAct()\r\n      }, this.props.autoPlayDelay)\r\n    }\r\n  }\r\n\r\n  ignoreTouch () {\r\n    return this.state.swiperItemCount <= 1\r\n  }\r\n\r\n  correctDurationAct () {\r\n    if (typeof this.props.duration !== 'number' || this.props.duration <= 0) {\r\n      this.setState({ isTransToX: false })\r\n      this.transEndFn()\r\n    }\r\n  }\r\n\r\n  swipeClick (e) {\r\n    e.preventDefault()\r\n    this.props.click && this.props.click(this.state.activeIndex)\r\n  }\r\n\r\n  gotoX (toX) {\r\n    if (this.state.transX === toX) {\r\n      // 已经手动滑到正确的位置\r\n      this.transEndFn()\r\n    } else {\r\n      // 自由滚动到合适的位置\r\n      this.setState({ isTransToX: true, transX: toX })\r\n      this.correctDurationAct()\r\n    }\r\n  }\r\n\r\n  goto (index) {\r\n    clearTimeout(_autoPlayTimer)\r\n    if (index < 1 || this.state.swiperItemCount === 1) {\r\n      activeIndex = 1\r\n    } else if (index > this.state.swiperItemCount - 2) {\r\n      activeIndex = this.state.swiperItemCount - 2\r\n    } else {\r\n      activeIndex = index\r\n    }\r\n    if (this.state.activeIndex !== activeIndex) {\r\n      this.setState({ activeIndex }, this.gotoX(-clientW * activeIndex))\r\n    } else {\r\n      this.autoPlayFn()\r\n    }\r\n    return activeIndex\r\n  }\r\n\r\n  isMobile () {\r\n    return navigator.userAgent.toLowerCase().match(/(ipod|iphone|android|coolpad|mmp|smartphone|midp|wap|xoom|symbian|j2me|blackberry|wince)/i) !== null;\r\n  }\r\n\r\n  render () {\r\n    return (\r\n      <div className=\"active-swiper-container\" ref=\"swiperContainer\"\r\n        style={{ width: clientW + 'px', height: this.props.clientH + 'px' }}\r\n        onClick={this.swipeClick.bind(this)} >\r\n        <div className=\"swiper-wrapper\" ref=\"sliderWrapper\"\r\n          style={{\r\n            transform: `translate3d(${this.state.transX}px, 0, 0)`,\r\n            transition: this.state.isTransToX ? `transform ${this.props.duration}ms cubic-bezier(0,0,0.25,1)` : '',\r\n          }}\r\n          onTouchStart={this.touchstartFn.bind(this)}\r\n          onTouchMove={this.touchmoveFn.bind(this)}\r\n          onTouchEnd={this.touchendFn.bind(this)}\r\n          onTransitionEnd={this.transitionendFn.bind(this)}>\r\n          {\r\n            this.state.currentList.map((item, index) => {\r\n              return <div className=\"img-box\" style={{ backgroundImage: `url(${item.url})`, backgroundSize: this.props.backgroundSize }} key={item._id}></div>\r\n            })\r\n          }\r\n        </div>\r\n        {\r\n          this.props.showCounter && this.state.swiperItemCount > 1\r\n          && <div className=\"swiper-pagination\" style={this.props.counterStyle}>\r\n            {`${this.state.activeIndex}/${this.state.swiperItemCount - 2}`}\r\n          </div>\r\n        }\r\n      </div>\r\n    )\r\n  }\r\n}\r\n\r\nexport default Swiper\r\n\r\nSwiper.propTypes = {\r\n  urlList: PropTypes.array.isRequired,\r\n  // 图片以何种缩放的形式铺在 滑动容器框内，只有当指定了 urlList 时才有效\r\n  backgroundSize: PropTypes.string,\r\n  // swiperContainer容器的宽度\r\n  clientW: PropTypes.number,\r\n  // swiperContainer容器的高度\r\n  clientH: PropTypes.number,\r\n  // 是否需要默认的计数器\r\n  showCounter: PropTypes.bool,\r\n  // 自定义默认计数器的样式 \r\n  counterStyle: PropTypes.object,\r\n  // 起始index\r\n  startIndex: PropTypes.number,\r\n  // 临界点的比例值，当超过这个临界点，则需要自动滑动到下一张图片\r\n  criticalValue: PropTypes.number,\r\n  // 自动滚动到稳定位置所需的时间，单位是秒(ms)\r\n  duration: PropTypes.number,\r\n  // 如果指定了此参数，并且值 >= 0，则将会将此值当做 delay的时间(单位为 ms)进行自动轮播；\r\n  // 不指定或指定值小于 0 则不自动轮播\r\n  // 如果想要指定此值，一般建议设置为 3000\r\n  autoPlayDelay: PropTypes.number\r\n}","import React, { Component } from 'react'\nimport Swiper from './components/Swiper'\n\nclass App extends Component {\n\n  constructor(props) {\n    super(props)\n    this.state = {\n      index: 1\n    }\n  }\n\n  inputIndex (e) {\n    this.setState({ index: e.target.value })\n  }\n\n  goto () {\n    let index = parseInt(this.state.index)\n    index = this.refs.swiper.goto(index)\n    this.setState({ index })\n  }\n\n  render () {\n    return (\n      <div>\n        <Swiper\n          urlList={[\n            'https://dummyimage.com/375x100/FB8A80?text=1',\n            'https://dummyimage.com/375x100/29A90F?text=2',\n            'https://dummyimage.com/375x100/6F9DFF?text=3'\n          ]}\n          showCounter={true}\n          click={(i) => { console.log('click', i) }}\n          change={(i) => { console.log('change', i) }}\n          ref=\"swiper\">\n        </Swiper>\n        <input type=\"number\" onChange={this.inputIndex.bind(this)} value={this.state.index}></input>\n        <button onClick={this.goto.bind(this)}>goto</button>\n      </div>)\n  }\n}\n\nexport default App","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}